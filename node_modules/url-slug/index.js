"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var unidecode = require('unidecode');
/* TODO v3
 * - Set default transformers as exports
 * - ESM with multiple exports
 * - Deprecate defaultTransformers
 * - Deprecate parseOptions, use a config object instead
 * - Deprecate null as separator
 * - Add support to NFKD normalize, make unidecode an option (full?)
 * - Browser support
 * - Add sentence case transformer
 * - Supported characters:
 *   - default: ALPHA / DIGIT / "-" / "." / "_" / "~"
 *   - path: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "&" /
 *           "'" / "(" / ")" / "*" / "+" / "," / ";" / "=" / "@"
 *     - ":" is non-zero-length segment without any colon, allow it?
 *   - query: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "'" / "(" /
 *            ")" / "*" / "+" / "," / ";" / "=" / "@" / "/" / "?"
 *     - "&" is commonly used to separate key/value pairs, allow it?
 *   - hash: ALPHA / DIGIT / "-" / "." / "_" / "~" / "!" / "$" / "&" / "'" /
 *           "(" / ")" / "*" / "+" / "," / ";" / "=" / "@" / "/" / "?"
 */


var INVALID_SEPARATOR = /[^-._~]/;
var CONVERT = /[A-Za-z\d]+/g;
var REVERT = /[^-._~]+/g;
var BASE = '(?:[a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))';
var CONVERT_CAMELCASE = new RegExp("[A-Za-z0-9]*?".concat(BASE, "|[A-Za-z0-9]+"), 'g');
var REVERT_CAMELCASE = new RegExp("[^-._~]*?".concat(BASE, "|[^-._~]+"), 'g');
var REVERT_CAMELCASE_WITH_EMPTY_SEPARATOR = new RegExp(".*?".concat(BASE, "|.+"), 'g');
/**
* Check and return validated options
*/

function parseOptions(options) {
  var camelCase;
  var separator;
  var transformer;

  if (2 === options.length) {
    var _options = _slicedToArray(options, 2);

    separator = _options[0];
    transformer = _options[1];
    validate({
      separator: separator,
      transformer: transformer
    });
  } else if (1 === options.length) {
    var option = options[0];

    if (false === option || 'function' === typeof option) {
      transformer = option;
      /* Don't validate */
    } else if (defaultTransformers[option]) {
      /* TODO Remove in v3 */
      transformer = option;
      validate({
        transformer: transformer
      });
      /* Throw deprecation error */
    } else if (typeof option === 'string') {
      separator = option;
      validate({
        separator: separator
      });
    } else if (option != null) {
      camelCase = option.camelCase;
      separator = option.separator;
      transformer = option.transformer;
      validate({
        camelCase: camelCase,
        separator: separator,
        transformer: transformer
      });
    }
  }

  if (defaultTransformers[transformer]) {
    /* Remove in v3.0.0 */
    transformer = defaultTransformers[transformer];
  }

  return {
    camelCase: camelCase,
    separator: separator == null ? void 0 : separator,
    transformer: transformer
  };
}
/**
* Validate options
*/


function validate(_ref) {
  var camelCase = _ref.camelCase,
      separator = _ref.separator,
      transformer = _ref.transformer;

  if (camelCase !== undefined) {
    if (typeof camelCase !== 'boolean') {
      throw new Error("camelCase must be a boolean: \"".concat(camelCase, "\"."));
    }
  }

  if (separator != null) {
    if ('string' !== typeof separator) {
      throw new Error("separator must be a string: \"".concat(separator, "\"."));
    } else if (INVALID_SEPARATOR.test(separator)) {
      throw new Error("separator has invalid characters: \"".concat(separator, "\"."));
    }
  }

  if (transformer != null) {
    if (transformer !== false && typeof transformer !== 'function') {
      if (typeof transformer === 'string' && defaultTransformers[transformer]) {
        throw new Error('Using transformer name as string was deprecated');
        /* TODO Remove in v3 */
      } else {
        throw new Error("transformer must be a function: \"".concat(transformer, "\"."));
      }
    }
  }
}

var UrlSlug = /*#__PURE__*/function () {
  _createClass(UrlSlug, null, [{
    key: "LOWERCASE_TRANSFORMER",
    value: function LOWERCASE_TRANSFORMER(fragments, separator) {
      return fragments.join(separator).toLowerCase();
    }
  }, {
    key: "UPPERCASE_TRANSFORMER",
    value: function UPPERCASE_TRANSFORMER(fragments, separator) {
      return fragments.join(separator).toUpperCase();
    }
  }, {
    key: "TITLECASE_TRANSFORMER",
    value: function TITLECASE_TRANSFORMER(fragments, separator) {
      return fragments.map(function (fragment) {
        return fragment.charAt(0).toUpperCase() + fragment.slice(1).toLowerCase();
      }).join(separator);
    }
    /**
    * Creates a new instance of url-slug
    */

  }]);

  function UrlSlug() {
    _classCallCheck(this, UrlSlug);

    for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
      options[_key] = arguments[_key];
    }

    var _parseOptions = parseOptions(options),
        _parseOptions$camelCa = _parseOptions.camelCase,
        camelCase = _parseOptions$camelCa === void 0 ? true : _parseOptions$camelCa,
        _parseOptions$separat = _parseOptions.separator,
        separator = _parseOptions$separat === void 0 ? '-' : _parseOptions$separat,
        _parseOptions$transfo = _parseOptions.transformer,
        transformer = _parseOptions$transfo === void 0 ? UrlSlug.LOWERCASE_TRANSFORMER : _parseOptions$transfo;

    this.camelCase = camelCase;
    this.separator = separator;
    this.transformer = transformer;
  }
  /**
  * Converts a string into a slug
  */


  _createClass(UrlSlug, [{
    key: "convert",
    value: function convert(string) {
      for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        options[_key2 - 1] = arguments[_key2];
      }

      var _parseOptions2 = parseOptions(options),
          _parseOptions2$camelC = _parseOptions2.camelCase,
          camelCase = _parseOptions2$camelC === void 0 ? this.camelCase : _parseOptions2$camelC,
          _parseOptions2$separa = _parseOptions2.separator,
          separator = _parseOptions2$separa === void 0 ? this.separator : _parseOptions2$separa,
          _parseOptions2$transf = _parseOptions2.transformer,
          transformer = _parseOptions2$transf === void 0 ? this.transformer : _parseOptions2$transf;

      var fragments = unidecode(String(string)).match(camelCase ? CONVERT_CAMELCASE : CONVERT);

      if (!fragments) {
        return '';
      }

      return transformer ? transformer(fragments, separator) : fragments.join(separator);
    }
    /**
    * Reverts a slug back to a string
    */

  }, {
    key: "revert",
    value: function revert(slug) {
      for (var _len3 = arguments.length, options = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        options[_key3 - 1] = arguments[_key3];
      }

      var _parseOptions3 = parseOptions(options),
          _parseOptions3$camelC = _parseOptions3.camelCase,
          camelCase = _parseOptions3$camelC === void 0 ? false : _parseOptions3$camelC,
          _parseOptions3$separa = _parseOptions3.separator,
          separator = _parseOptions3$separa === void 0 ? null : _parseOptions3$separa,
          _parseOptions3$transf = _parseOptions3.transformer,
          transformer = _parseOptions3$transf === void 0 ? false : _parseOptions3$transf;

      var fragments;
      slug = String(slug);
      /* Determine which method will be used split the slug */

      if ('' === separator) {
        fragments = slug.match(REVERT_CAMELCASE_WITH_EMPTY_SEPARATOR);
      } else if ('string' === typeof separator) {
        fragments = slug.split(separator);
      } else {
        fragments = slug.match(camelCase ? REVERT_CAMELCASE : REVERT);
      }

      if (!fragments) {
        return '';
      }

      return transformer ? transformer(fragments, ' ') : fragments.join(' ');
    }
  }]);

  return UrlSlug;
}();
/**
* Builtin transformers
*/


var defaultTransformers = {
  /* TODO Deprecate in v3 */
  lowercase: UrlSlug.LOWERCASE_TRANSFORMER,
  uppercase: UrlSlug.UPPERCASE_TRANSFORMER,
  titlecase: UrlSlug.TITLECASE_TRANSFORMER
};
/* Prepare the global instance and export it */

var urlSlug = new UrlSlug();
var global = urlSlug.convert.bind(urlSlug);
global.UrlSlug = UrlSlug;
global.convert = global;
global.revert = urlSlug.revert.bind(urlSlug);
global.transformers = defaultTransformers;
/* TODO Deprecate in v3 */

module.exports = global;